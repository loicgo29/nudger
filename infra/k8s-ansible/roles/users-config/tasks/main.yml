---
# NOTE: All system-level tasks use become: true when touching /opt, /usr/local/bin, etc.

# 1) Ensure required groups exist (deduped across all users)
- name: Ensure groups referenced by users_k8s exist
  ansible.builtin.group:
    name: "{{ item }}"
    state: present
  loop: "{{ users_k8s | map(attribute='groups') | select('defined') | list | flatten | unique }}"
  when: (users_k8s | length) > 0

# 2) Create users with optional password hash and groups
- name: Ensure users exist with requested properties
  ansible.builtin.user:
    name: "{{ item.name }}"
    password: "{{ (item.password_hash | default('')) if (item.password_hash | default('') | length) > 0 else omit }}"
    groups: "{{ item.groups | default([]) }}"
    shell: /bin/bash
    create_home: true
  loop: "{{ users_k8s }}"

# 3) Sudoers NOPASSWD per-user (careful: least privilege)
- name: Configure passwordless sudo when requested
  ansible.builtin.copy:
    dest: "/etc/sudoers.d/{{ item.name }}"
    content: "{{ item.name }} ALL=(ALL) NOPASSWD:ALL\n"
    owner: root
    group: root
    mode: '0440'
    validate: 'visudo -cf %s'
  loop: "{{ users_k8s }}"
  when: item.sudo_nopass | default(false)
  become: true

# 4) Authorized keys (no private keys copied)
- name: Ensure ~/.ssh exists for each user
  ansible.builtin.file:
    path: "/home/{{ item.name }}/.ssh"
    state: directory
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0700'
  loop: "{{ users_k8s }}"
  become: true

# List of keys (ssh_public_keys: [])
- name: Add SSH authorized keys (list)
  ansible.builtin.authorized_key:
    user: "{{ item.0.name }}"
    key: "{{ item.1 }}"
    state: present
  loop: "{{ users_k8s | subelements('ssh_public_keys', skip_missing=True) }}"
  loop_control:
    label: "{{ item.0.name }}"
  become: true

# Single key (ssh_public_key: "ssh-ed25519 ...")
- name: Add SSH authorized key (single)
  ansible.builtin.authorized_key:
    user: "{{ item.name }}"
    key: "{{ item.ssh_public_key }}"
    state: present
  loop: "{{ users_k8s }}"
  when: item.ssh_public_key is defined and (item.ssh_public_key | length) > 0
  become: true

# 5) Kubeconfig: copy existing OR render template
- name: Ensure ~/.kube exists
  ansible.builtin.file:
    path: "/home/{{ item.name }}/.kube"
    state: directory
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0700'
  loop: "{{ users_k8s }}"

- name: Copy kubeconfig when provided (kubeconfig or kubeconfig_src)
  ansible.builtin.copy:
    src: "{{ item.kubeconfig_src | default(item.kubeconfig) }}"
    dest: "/home/{{ item.name }}/.kube/config"
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0600'
    remote_src: true
  loop: "{{ users_k8s }}"
  when: (item.kubeconfig_src | default(item.kubeconfig | default(''))) | length > 0

- name: Render kubeconfig from template when requested
  ansible.builtin.template:
    src: "kubeconfig.j2"
    dest: "/home/{{ item.name }}/.kube/config"
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0600'
  loop: "{{ users_k8s }}"
  vars:
    user_name: "{{ item.name }}"
  when: item.kubeconfig_template | default(false)

- name: Ensure KUBECONFIG in .bashrc
  ansible.builtin.lineinfile:
    path: "/home/{{ item.name }}/.bashrc"
    regexp: '^\s*export KUBECONFIG='
    line: 'export KUBECONFIG=$HOME/.kube/config'
    create: true
  loop: "{{ users_k8s }}"

# 6) Bash aliases: deploy and ensure sourced in .bashrc
- name: Deploy bash aliases file
  ansible.builtin.copy:
    src: "bash_aliases"
    dest: "/home/{{ item.name }}/{{ bash_aliases_file }}"
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0644'
  loop: "{{ users_k8s }}"
  when: bash_aliases_enable | default(true)

- name: Ensure .bash_aliases is sourced in .bashrc (idempotent)
  ansible.builtin.lineinfile:
    path: "/home/{{ item.name }}/{{ bashrc_file }}"
    regexp: '^\s*source\s+~/.bash_aliases'
    line: 'source ~/.bash_aliases'
    create: true
    state: present
  loop: "{{ users_k8s }}"
  when: bash_aliases_enable | default(true)

# 7) kubectl completion per user (only generates if not present)
- name: Ensure bash-completion dir exists for each user
  ansible.builtin.file:
    path: "/home/{{ item.name }}/.local/share/bash-completion/completions"
    state: directory
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0700'
  loop: "{{ users_k8s }}"
  when: kubectl_completion_enable | default(true)

- name: Generate kubectl completion file (idempotent via creates)
  ansible.builtin.shell: >
    kubectl completion bash >
    /home/{{ item.name }}/.local/share/bash-completion/completions/kubectl
  args:
    creates: "/home/{{ item.name }}/.local/share/bash-completion/completions/kubectl"
  become: true
  become_user: "{{ item.name }}"
  loop: "{{ users_k8s }}"
  when: kubectl_completion_enable | default(true)

# 8) Create ~/bin and symlink common tools for each user (optional convenience)
- name: Ensure per-user ~/bin exists
  ansible.builtin.file:
    path: "/home/{{ item.name }}/bin"
    state: directory
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0755'
  loop: "{{ users_k8s }}"

# If you keep this, it only links existing binaries (no git involved here)
- name: Stat tool binaries on remote hosts (per user/tool pair)
  ansible.builtin.stat:
    path: "{{ item.1.src }}"
  register: tools_stat
  loop: "{{ users_k8s | product(tools_symlinks | default([])) | list }}"
  loop_control:
    label: "{{ item.0.name }} <- {{ item.1.name }}"

- name: Symlink tools into per-user ~/bin (only if src exists on remote)
  ansible.builtin.file:
    src: "{{ item.item.1.src }}"
    dest: "/home/{{ item.item.0.name }}/bin/{{ item.item.1.name }}"
    state: link
    force: true
  loop: "{{ tools_stat.results | default([]) }}"
  when: item.stat.exists
  loop_control:
    label: "{{ item.item.0.name }} <- {{ item.item.1.name }}"

