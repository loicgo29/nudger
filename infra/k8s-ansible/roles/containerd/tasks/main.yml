---
# Installe containerd, K8s 1.31, init le master, applique Flannel.

# ----------------------------
# System prep
# ----------------------------
- name: Ensure br_netfilter kernel module is loaded
  community.general.modprobe:
    name: br_netfilter
    state: present
  become: true
  tags: preflight

- name: Ensure required sysctl params are set
  ansible.builtin.sysctl:
    name: "{{ item.key }}"
    value: "{{ item.value }}"
    sysctl_set: true
    state: present
    reload: true
  loop: "{{ sysctl_params | dict2items }}"
  become: true
  tags: preflight

- name: Disable swap immediately
  ansible.builtin.command: swapoff -a
  when: ansible_swaptotal_mb | int > 0
  become: true
  changed_when: false
  tags: preflight

- name: Ensure swap is disabled on boot (comment fstab entries)
  ansible.builtin.replace:
    path: /etc/fstab
    regexp: '^\s*([^#]\S+\s+\S+\s+swap\s+\S+.*)$'
    replace: '# \1'
  become: true
  tags: preflight

# ----------------------------
# Containerd
# ----------------------------
- name: Remove legacy containerd config if present
  ansible.builtin.file:
    path: /etc/containerd/config.toml
    state: absent
  become: true
  tags: containerd

- name: Install containerd
  ansible.builtin.apt:
    name: containerd
    state: present
    update_cache: yes
  become: true
  tags: containerd

- name: Ensure /etc/containerd dir exists
  ansible.builtin.file:
    path: /etc/containerd
    state: directory
    mode: '0755'
  become: true
  tags: containerd

- name: Write crictl.yaml pointing to containerd
  ansible.builtin.copy:
    dest: /etc/crictl.yaml
    mode: '0644'
    content: |
      runtime-endpoint: unix:///var/run/containerd/containerd.sock
      image-endpoint: unix:///var/run/containerd/containerd.sock
      timeout: 10
      debug: false
  become: true
  tags: containerd

- name: Deploy containerd config
  ansible.builtin.copy:
    dest: /etc/containerd/config.toml
    mode: '0644'
    content: "{{ containerd_config }}"
  notify: Restart containerd
  become: true
  tags: containerd

- name: Ensure containerd is running and enabled
  ansible.builtin.systemd:
    name: containerd
    state: started
    enabled: true
  become: true
  tags: containerd

# ----------------------------
# Kubernetes repo & packages (FORCE v1.31)
# ----------------------------

# Dépendances apt https + gpg
- name: Ensure deps for HTTPS APT
  ansible.builtin.apt:
    name:
      - ca-certificates
      - curl
      - gpg
    state: present
    update_cache: yes
  become: true
  tags: k8s

# Nettoyage d’éventuels restes de repos/keys conflictuels
- name: Purge any previous Kubernetes sources
  ansible.builtin.shell: |
    rm -f /etc/apt/sources.list.d/kubernetes.list
    sed -i '/pkgs\.k8s\.io\/core:\/stable:\//d' /etc/apt/sources.list || true
  args: { executable: /bin/bash }
  changed_when: true
  become: true
  tags: k8s

- name: Remove legacy keyring if present
  ansible.builtin.file:
    path: /etc/apt/keyrings/kubernetes-apt-keyring.gpg
    state: absent
  become: true
  tags: k8s

- name: Ensure /etc/apt/keyrings exists
  ansible.builtin.file:
    path: /etc/apt/keyrings
    state: directory
    mode: "0755"
  become: true
  tags: k8s

# Clé + keyring archive (canonique)
- name: Fetch Kubernetes Release.key (v1.31)
  ansible.builtin.get_url:
    url: "https://pkgs.k8s.io/core:/stable:/v1.31/deb/Release.key"
    dest: /etc/apt/keyrings/kubernetes-Release.key
    mode: "0644"
  become: true
  tags: k8s

- name: Dearmor -> kubernetes-archive-keyring.gpg
  ansible.builtin.command:
    cmd: "gpg --dearmor -o /etc/apt/keyrings/kubernetes-archive-keyring.gpg /etc/apt/keyrings/kubernetes-Release.key"
  args:
    creates: /etc/apt/keyrings/kubernetes-archive-keyring.gpg
  become: true
  tags: k8s

- name: Ensure keyring perms
  ansible.builtin.file:
    path: /etc/apt/keyrings/kubernetes-archive-keyring.gpg
    state: file
    mode: "0644"
  become: true
  tags: k8s

# Source APT écrite à la main (évite les conflits apt_repository)
- name: Write kubernetes.list (v1.31)
  ansible.builtin.copy:
    dest: /etc/apt/sources.list.d/kubernetes.list
    mode: "0644"
    content: |
      deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.31/deb/ /
  become: true
  tags: k8s

- name: apt-get update (force refresh)
  ansible.builtin.shell: |
    rm -rf /var/lib/apt/lists/*
    apt-get update
  args: { executable: /bin/bash }
  register: apt_update_out
  changed_when: false
  become: true
  tags: k8s

# Debug rapide (peut être retiré après validation)
- name: Show apt-cache policy kube*
  ansible.builtin.shell: |
    apt-cache policy kubeadm kubelet kubectl | sed -n '1,160p'
  args: { executable: /bin/bash }
  register: kube_policies
  changed_when: false
  become: true
  tags: k8s

- debug:
    var: kube_policies.stdout_lines
  tags: k8s

# Enlève des holds éventuels puis installe/upgrade
- name: Unhold kube packages if held
  ansible.builtin.shell: |
    set -e
    for p in kubeadm kubelet kubectl; do
      if apt-mark showhold | grep -q "^$p$"; then apt-mark unhold "$p"; fi
    done
  args: { executable: /bin/bash }
  changed_when: false
  become: true
  tags: k8s

- name: Install/upgrade Kubernetes tools to latest in v1.31 repo
  ansible.builtin.apt:
    name: "{{ k8s_packages }}"
    state: latest
    update_cache: yes
  become: true
  tags: k8s

- name: Enable & restart kubelet
  ansible.builtin.systemd:
    name: kubelet
    enabled: true
    state: restarted
  become: true
  tags: k8s

- name: Get kubeadm version (semver)
  ansible.builtin.command: kubeadm version -o short
  register: kubeadm_ver
  changed_when: false
- name: Use installed kubeadm version for template
  ansible.builtin.set_fact:
    kubeadm_semver: "{{ kubeadm_ver.stdout | trim }}"

# On compare seulement X.Y
- name: Ensure kubeadm minor matches requested release
  ansible.builtin.assert:
    that:
      - "(kubeadm_ver.stdout
          | trim
          | regex_replace('^v', '')
          | regex_replace('^(\\d+\\.\\d+).*', '\\1'))
         ==
         (k8s_release
          | trim
          | regex_replace('^v', '')
          | regex_replace('^(\\d+\\.\\d+).*', '\\1'))"
    fail_msg: "kubeadm {{ kubeadm_ver.stdout | trim }} ne matche pas la branche {{ k8s_release }}"
    success_msg: "kubeadm {{ kubeadm_ver.stdout | trim }} matche bien {{ k8s_release }}"
# ----------------------------
# Init master
# ----------------------------
- name: Check if cluster already initialized
  ansible.builtin.stat:
    path: "{{ kubeconfig_admin_path }}"
  register: kubeadm_config
  become: true
  tags: init

- name: Default apiserver_endpoint if undefined (single master)
  ansible.builtin.set_fact:
    apiserver_endpoint: "{{ ansible_default_ipv4.address }}:6443"
  when: apiserver_endpoint is not defined or (apiserver_endpoint | trim) == ''
  become: false
  tags: init

- name: Render kubeadm config
  ansible.builtin.template:
    src: kubeadm-config.j2
    dest: /root/kubeadm-config.yaml
    mode: '0644'
  when: inventory_hostname == groups['k8s_masters'][0]
  become: true
  tags: init

# === DEBUG: montre ce qu'il y a VRAIMENT dans le fichier actuel ===
- name: Show current /root/kubeadm-config.yaml (debug)
  become: true
  ansible.builtin.shell: cat /root/kubeadm-config.yaml || true
  register: kubeadm_cfg_before
  changed_when: false
  tags: init

- debug:
    var: kubeadm_cfg_before.stdout
  tags: init
- name: Get kubeadm version (semver)
  ansible.builtin.command: kubeadm version -o short
  register: kubeadm_ver
  changed_when: false
  failed_when: kubeadm_ver.rc != 0

- name: Use installed kubeadm version for kubernetesVersion
  ansible.builtin.set_fact:
    kubeadm_semver: "{{ kubeadm_ver.stdout | trim }}"

# (optionnel) re-montrer le rendu pour sanity check
- name: Show new /root/kubeadm-config.yaml
  become: true
  ansible.builtin.shell: cat /root/kubeadm-config.yaml
  register: kubeadm_cfg_after
  changed_when: false
  tags: init

- debug:
    var: kubeadm_cfg_after.stdout
  tags: init


- name: Initialize control-plane (skip kube-proxy)
  ansible.builtin.command: kubeadm init --config=/root/kubeadm-config.yaml --skip-phases=addon/kube-proxy
  args:
    creates: "{{ kubeconfig_admin_path }}"
  when:
    - inventory_hostname == groups['k8s_masters'][0]
    - not kubeadm_config.stat.exists
  become: true
  tags: init

# --- Wait API ready ---
- name: Wait for API server port 6443 to be listening (local)
  ansible.builtin.wait_for:
    host: "127.0.0.1"
    port: 6443
    timeout: 180
    delay: 5
  when: inventory_hostname == groups['k8s_masters'][0]
  become: true
  tags: apiserver_wait

- name: Wait for API server /readyz to return ok
  ansible.builtin.command: kubectl get --raw=/readyz?verbose
  environment:
    KUBECONFIG: "{{ kubeconfig_admin_path }}"
  register: apiready
  changed_when: false
  until: apiready.rc == 0 and ('ok' in apiready.stdout)
  retries: 60
  delay: 5
  when: inventory_hostname == groups['k8s_masters'][0]
  tags: apiserver_wait

# --- kube-proxy ---
- name: Check if kube-proxy DaemonSet already exists
  ansible.builtin.command: kubectl -n kube-system get ds kube-proxy -o name
  environment:
    KUBECONFIG: "{{ kubeconfig_admin_path }}"
  register: kp_ds
  changed_when: false
  failed_when: false
  when: inventory_hostname == groups['k8s_masters'][0]
  tags: kube_proxy

- name: Run kubeadm init phase addon kube-proxy
  ansible.builtin.command: kubeadm init phase addon kube-proxy --v=4
  environment:
    KUBECONFIG: "{{ kubeconfig_admin_path }}"
  register: kp_phase
  changed_when: "'applied' in kp_phase.stdout or 'created' in kp_phase.stdout"
  when:
    - inventory_hostname == groups['k8s_masters'][0]
    - kp_ds.rc != 0 or (kp_ds.stdout | length) == 0
  retries: 10
  delay: 6
  become: true
  tags: kube_proxy

# --- kube-proxy: inspecter clairement l'état avant d'attendre ---
- name: Show kube-proxy DaemonSet status (quick view)
  ansible.builtin.command: kubectl -n kube-system get ds kube-proxy -o wide
  environment:
    KUBECONFIG: "{{ kubeconfig_admin_path }}"
  changed_when: false

- name: Show kube-proxy pods
  ansible.builtin.command: kubectl -n kube-system get pods -l k8s-app=kube-proxy -o wide
  environment:
    KUBECONFIG: "{{ kubeconfig_admin_path }}"
  changed_when: false

- name: Get kube-proxy DS numbers (json)
  ansible.builtin.command: >
    kubectl -n kube-system get ds kube-proxy
    -o jsonpath='{.status.desiredNumberScheduled}:{.status.numberAvailable}:{.status.numberReady}'
  environment:
    KUBECONFIG: "{{ kubeconfig_admin_path }}"
  register: kp_nums
  changed_when: false

- name: Wait kube-proxy becomes available (polling instead of long blocking)
  ansible.builtin.command: >
    kubectl -n kube-system get ds kube-proxy
    -o jsonpath='{.status.numberAvailable}'
  environment:
    KUBECONFIG: "{{ kubeconfig_admin_path }}"
  register: kp_ready
  until: (kp_ready.stdout | int) > 0
  retries: 36          # ~3 minutes (36 * 5s)
  delay: 5
  changed_when: false

# ----------------------------
# Kubeconfig pour l'user ansible
# ----------------------------
- name: Ensure .kube directory exists for ansible user
  ansible.builtin.file:
    path: "/home/{{ ansible_user | default('ansible') }}/.kube"
    state: directory
    mode: '0700'
    owner: "{{ ansible_user | default('ansible') }}"
    group: "{{ ansible_user | default('ansible') }}"
  become: true
  when: inventory_hostname == groups['k8s_masters'][0]
  tags: kubeconfig

- name: Copy admin.conf to ansible user home
  ansible.builtin.copy:
    src: "{{ kubeconfig_admin_path }}"
    dest:  "{{ kubeconfig }}"
    owner: "{{ ansible_user | default('ansible') }}"
    group: "{{ ansible_user | default('ansible') }}"
    mode: '0600'
    remote_src: true
  become: true
  when: inventory_hostname == groups['k8s_masters'][0]
  tags: kubeconfig

- name: Ensure KUBECONFIG line in ansible user's .bashrc
  ansible.builtin.lineinfile:
    path: "/home/{{ ansible_user | default('ansible') }}/.bashrc"
    line: 'export KUBECONFIG=$HOME/.kube/config'
    create: true
    state: present
  become: true
  when: inventory_hostname == groups['k8s_masters'][0]
  tags: kubeconfig

# ----------------------------
# Flannel CNI
# ----------------------------
- name: Apply Flannel CNI manifest
  ansible.builtin.command:
    cmd: "kubectl apply -f {{ flannel_manifest_url }}"
  environment:
    KUBECONFIG: "{{ kubeconfig_admin_path }}"
  register: flannel_apply
  changed_when: "'created' in flannel_apply.stdout or 'configured' in flannel_apply.stdout"
  become: true
  when: inventory_hostname == groups['k8s_masters'][0]
  tags: flannel

- name: Detect Flannel namespace by label
  ansible.builtin.command: >
    kubectl get ds -A -l app=flannel -o jsonpath='{.items[0].metadata.namespace}'
  environment:
    KUBECONFIG: "{{ kubeconfig_admin_path }}"
  register: flannel_ns_detect
  changed_when: false
  failed_when: flannel_ns_detect.rc != 0 or flannel_ns_detect.stdout | length == 0
  become: true
  when: inventory_hostname == groups['k8s_masters'][0]
  tags: flannel

- name: Wait for Flannel DaemonSet rollout
  ansible.builtin.command: >
    kubectl -n {{ flannel_ns_detect.stdout }}
    rollout status ds/kube-flannel-ds --timeout={{ flannel_wait_timeout }}
  environment:
    KUBECONFIG: "{{ kubeconfig_admin_path }}"
  register: flannel_rollout
  changed_when: false
  failed_when: flannel_rollout.rc != 0
  become: true
  when: inventory_hostname == groups['k8s_masters'][0]
  tags: flannel

- name: Flush handlers now (may restart kubelet/containerd)
  meta: flush_handlers

- name: Wait for API server /readyz to be ok (post-handlers)
  ansible.builtin.uri:
    url: https://127.0.0.1:6443/readyz
    method: GET
    validate_certs: false
    return_content: true
    status_code: 200
  register: readyz
  until: readyz.status == 200 and ('ok' in readyz.content)
  retries: 60
  delay: 2

# (cluster mono-nœud) autoriser le scheduling sur le control-planeA
- name: Also clear legacy master taint if present
  ansible.builtin.command: >
    kubectl taint nodes --all node-role.kubernetes.io/master-
  environment:
    KUBECONFIG: "{{ kubeconfig_admin_path }}"
  when:
    - inventory_hostname == groups['k8s_masters'][0]
    - allow_scheduling_on_control_plane | default(false) | bool
  register: taint_rm_legacy
  failed_when: false
  changed_when: taint_rm_legacy.rc == 0
  tags: taints

