---
# NOTE: All system-level tasks use become: true when touching /opt, /usr/local/bin, etc.

# 1) Ensure required groups exist (deduped across all users)
- name: Ensure groups referenced by users_k8s exist
  ansible.builtin.group:
    name: "{{ item }}"
    state: present
  loop: "{{ users_k8s | map(attribute='groups') | select('defined') | list | flatten | unique }}"
  when: (users_k8s | length) > 0

# 2) Create users with optional password hash and groups
- name: Ensure users exist with requested properties
  ansible.builtin.user:
    name: "{{ item.name }}"
    password: "{{ (item.password_hash | default('')) if (item.password_hash | default('') | length) > 0 else omit }}"
    groups: "{{ item.groups | default([]) }}"
    shell: /bin/bash
    create_home: true
  loop: "{{ users_k8s }}"

# 3) Sudoers NOPASSWD per-user (careful: least privilege)
- name: Configure passwordless sudo when requested
  ansible.builtin.copy:
    dest: "/etc/sudoers.d/{{ item.name }}"
    content: "{{ item.name }} ALL=(ALL) NOPASSWD:ALL\n"
    owner: root
    group: root
    mode: '0440'
  loop: "{{ users_k8s }}"
  when: item.sudo_nopass | default(false)
  become: true

# 4) Authorized keys (safer than copying private keys)
# Ensure ~/.ssh exists for each user
- name: Ensure ~/.ssh exists for each user
  ansible.builtin.file:
    path: "/home/{{ item.name }}/.ssh"
    state: directory
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0700'
  loop: "{{ users_k8s }}"
  become: true

# List of keys (ssh_public_keys: [])
- name: Add SSH authorized keys (list)
  ansible.builtin.authorized_key:
    user: "{{ item.0.name }}"
    key: "{{ item.1 }}"
    state: present
    # Tip: set manage_dir: true if you don't run the mkdir task above
    # manage_dir: true
  loop: "{{ users_k8s | subelements('ssh_public_keys', skip_missing=True) }}"
  loop_control:
    label: "{{ item.0.name }}"
  become: true

# Single key (ssh_public_key: "ssh-ed25519 ...")
- name: Add SSH authorized key (single)
  ansible.builtin.authorized_key:
    user: "{{ item.name }}"
    key: "{{ item.ssh_public_key }}"
    state: present
  loop: "{{ users_k8s }}"
  when: item.ssh_public_key is defined and (item.ssh_public_key | length) > 0
  become: true

# 5) Kubeconfig: copy existing OR render template
#    Rationale: Some envs expose /etc/kubernetes/admin.conf; others prefer user-scoped config via template.
- name: Ensure ~/.kube exists
  ansible.builtin.file:
    path: "/home/{{ item.name }}/.kube"
    state: directory
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0700'
  loop: "{{ users_k8s }}"

- name: Copy kubeconfig when provided (kubeconfig or kubeconfig_src)
  ansible.builtin.copy:
    src: "{{ item.kubeconfig_src | default(item.kubeconfig) }}"
    dest: "/home/{{ item.name }}/.kube/config"
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0600'
    remote_src: true
  loop: "{{ users_k8s }}"
  when: (item.kubeconfig_src | default(item.kubeconfig | default(''))) | length > 0

- name: Render kubeconfig from template when requested
  ansible.builtin.template:
    src: "kubeconfig.j2"
    dest: "/home/{{ item.name }}/.kube/config"
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0600'
  loop: "{{ users_k8s }}"
  vars:
    user_name: "{{ item.name }}"
  when: item.kubeconfig_template | default(false)
  # Complexity note: we pass per-user user_name into the template; apiserver_host comes from defaults.
- name: Ensure KUBECONFIG in .bashrc
  ansible.builtin.lineinfile:
    path: "/home/{{ item.name }}/.bashrc"
    regexp: '^\s*export KUBECONFIG='
    line: 'export KUBECONFIG=$HOME/.kube/config'
    create: true
  loop: "{{ users_k8s }}"

# 6) Bash aliases: deploy and ensure sourced in .bashrc
- name: Deploy bash aliases file
  ansible.builtin.copy:
    src: "bash_aliases"
    dest: "/home/{{ item.name }}/{{ bash_aliases_file }}"
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0644'
  loop: "{{ users_k8s }}"
  when: bash_aliases_enable | default(true)

- name: Ensure .bash_aliases is sourced in .bashrc (idempotent)
  ansible.builtin.lineinfile:
    path: "/home/{{ item.name }}/{{ bashrc_file }}"
    regexp: '^\s*source\s+~/.bash_aliases'
    line: 'source ~/.bash_aliases'
    create: true
    state: present
  loop: "{{ users_k8s }}"
  when: bash_aliases_enable | default(true)

# 7) kubectx/kubens system-wide (once) + symlinks
- name: Checkout kubectx repo (system-wide)
  ansible.builtin.git:
    repo: "https://github.com/ahmetb/kubectx.git"
    dest: "{{ kubectx_checkout_dir }}"
    version: master
    update: yes
  when: (install_kubectx or install_kubens)
  become: true

- name: Symlink kubectx into /usr/local/bin
  ansible.builtin.file:
    src: "{{ kubectx_checkout_dir }}/kubectx"
    dest: "/usr/local/bin/kubectx"
    state: link
    force: true
  when: install_kubectx | default(false)
  become: true

- name: Symlink kubens into /usr/local/bin
  ansible.builtin.file:
    src: "{{ kubectx_checkout_dir }}/kubens"
    dest: "/usr/local/bin/kubens"
    state: link
    force: true
  when: install_kubens | default(false)
  become: true

# 8) kubectl completion per user (only generates if not present)
- name: Ensure bash-completion dir exists for each user
  ansible.builtin.file:
    path: "/home/{{ item.name }}/.local/share/bash-completion/completions"
    state: directory
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0700'
  loop: "{{ users_k8s }}"
  when: kubectl_completion_enable | default(true)

- name: Generate kubectl completion file (idempotent via creates)
  ansible.builtin.shell: >
    kubectl completion bash >
    /home/{{ item.name }}/.local/share/bash-completion/completions/kubectl
  args:
    creates: "/home/{{ item.name }}/.local/share/bash-completion/completions/kubectl"
  become: true
  become_user: "{{ item.name }}"
  loop: "{{ users_k8s }}"
  when: kubectl_completion_enable | default(true)

# 9) Per-user Git config (only when provided)
- name: Configure per-user git user.name
  ansible.builtin.git_config:
    name: user.name
    value: "{{ item.git.name }}"
    scope: global
  become: true
  become_user: "{{ item.name }}"
  loop: "{{ users_k8s }}"
  when: item.git is defined and (item.git.name | default('')) | length > 0

- name: Configure per-user git user.email
  ansible.builtin.git_config:
    name: user.email
    value: "{{ item.git.email }}"
    scope: global
  become: true
  become_user: "{{ item.name }}"
  loop: "{{ users_k8s }}"
  when: item.git is defined and (item.git.email | default('')) | length > 0

# 10) Clone repos for each user
# Use subelements to iterate (user, repo) pairs. No nested/duplicate loops.
- name: Keep SSH_AUTH_SOCK when sudo (so agent forwarding survives)
  ansible.builtin.copy:
    dest: /etc/sudoers.d/keep-ssh-auth-sock
    content: 'Defaults env_keep += "SSH_AUTH_SOCK"'
    owner: root
    group: root
    mode: '0440'
    validate: 'visudo -cf %s'
  become: true

- name: Ensure github.com is in known_hosts for each user
  ansible.builtin.known_hosts:
    path: "/home/{{ item.name }}/.ssh/known_hosts"
    name: github.com
    key: "{{ lookup('pipe', 'ssh-keyscan -t ed25519 github.com 2>/dev/null') }}"
    state: present
  loop: "{{ users_k8s }}"
  become: true
  become_user: "{{ item.name }}"

- name: Clone repos for each user (HTTPS read-only)
  ansible.builtin.git:
    repo: "{{ item.1.repo | regex_replace('^git@github.com:', 'https://github.com/') }}"
    dest: "/home/{{ item.0.name }}/{{ (item.1.dest | default('nudger')) | basename }}"
    version: "{{ item.1.version | default('main') }}"
    accept_hostkey: true
  become: true
  become_user: "{{ item.0.name }}"
  loop: "{{ users_k8s | subelements('git_repos', skip_missing=True) }}"
  loop_control:
    label: "{{ item.0.name }} -> {{ item.1.repo }}"

# 11) Create ~/bin and symlink common tools for each user
- name: Ensure per-user ~/bin exists
  ansible.builtin.file:
    path: "/home/{{ item.name }}/bin"
    state: directory
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0755'
  loop: "{{ users_k8s }}"

# We must check tool presence on the *remote* before linking.
# Strategy: build (user, tool) pairs via product, stat each tool.src remotely,
# then create the link only when the src exists.
- name: Stat tool binaries on remote hosts (per user/tool pair)
  ansible.builtin.stat:
    path: "{{ item.1.src }}"
  register: tools_stat
  loop: "{{ users_k8s | product(tools_symlinks) | list }}"
  loop_control:
    label: "{{ item.0.name }} <- {{ item.1.name }}"

- name: Symlink tools into per-user ~/bin (only if src exists on remote)
  ansible.builtin.file:
    src: "{{ item.item.1.src }}"
    dest: "/home/{{ item.item.0.name }}/bin/{{ item.item.1.name }}"
    state: link
    force: true
  loop: "{{ tools_stat.results }}"
  when: item.stat.exists
  loop_control:
    label: "{{ item.item.0.name }} <- {{ item.item.1.name }}"

