---
# NOTE: All system-level tasks use become: true when touching /opt, /usr/local/bin, etc.

# 1) Ensure required groups exist (deduped across all users)
- name: Ensure groups referenced by users_k8s exist
  ansible.builtin.group:
    name: "{{ item }}"
    state: present
  loop: "{{ users_k8s | map(attribute='groups') | select('defined') | list | flatten | unique }}"
  when: (users_k8s | length) > 0

# 2) Create users with optional password hash and groups
- name: Ensure users exist with requested properties
  ansible.builtin.user:
    name: "{{ item.name }}"
    password: "{{ (item.password_hash | default('')) if (item.password_hash | default('') | length) > 0 else omit }}"
    groups: "{{ item.groups | default([]) }}"
    shell: /bin/bash
    create_home: true
  loop: "{{ users_k8s }}"

# 3) Sudoers NOPASSWD per-user (careful: least privilege)
- name: Configure passwordless sudo when requested
  ansible.builtin.copy:
    dest: "/etc/sudoers.d/{{ item.name }}"
    content: "{{ item.name }} ALL=(ALL) NOPASSWD:ALL\n"
    owner: root
    group: root
    mode: '0440'
    validate: 'visudo -cf %s'
  loop: "{{ users_k8s }}"
  when: item.sudo_nopass | default(false)
  become: true

# 4) Authorized keys (no private keys copied)
- name: Ensure ~/.ssh exists for each user
  ansible.builtin.file:
    path: "/home/{{ item.name }}/.ssh"
    state: directory
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0700'
  loop: "{{ users_k8s }}"
  become: true

# List of keys (ssh_public_keys: [])
- name: Add SSH authorized keys (list)
  ansible.builtin.authorized_key:
    user: "{{ item.0.name }}"
    key: "{{ item.1 }}"
    state: present
  loop: "{{ users_k8s | subelements('ssh_public_keys', skip_missing=True) }}"
  loop_control:
    label: "{{ item.0.name }}"
  become: true

# Single key (ssh_public_key: "ssh-ed25519 ...")
- name: Add SSH authorized key (single)
  ansible.builtin.authorized_key:
    user: "{{ item.name }}"
    key: "{{ item.ssh_public_key }}"
    state: present
  loop: "{{ users_k8s }}"
  when: item.ssh_public_key is defined and (item.ssh_public_key | length) > 0
  become: true

# 5) Kubeconfig: copy existing OR render template
- name: Ensure ~/.kube exists
  ansible.builtin.file:
    path: "/home/{{ item.name }}/.kube"
    state: directory
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0700'
  loop: "{{ users_k8s }}"

- name: Copy kubeconfig when provided (kubeconfig or kubeconfig_src)
  ansible.builtin.copy:
    src: "{{ item.kubeconfig_src | default(item.kubeconfig) }}"
    dest: "/home/{{ item.name }}/.kube/config"
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0600'
    remote_src: true
  loop: "{{ users_k8s }}"
  when: (item.kubeconfig_src | default(item.kubeconfig | default(''))) | length > 0

- name: Render kubeconfig from template when requested
  ansible.builtin.template:
    src: "kubeconfig.j2"
    dest: "/home/{{ item.name }}/.kube/config"
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0600'
  loop: "{{ users_k8s }}"
  vars:
    user_name: "{{ item.name }}"
  when: item.kubeconfig_template | default(false)

- name: Ensure KUBECONFIG in .bashrc
  ansible.builtin.lineinfile:
    path: "/home/{{ item.name }}/.bashrc"
    regexp: '^\s*export KUBECONFIG='
    line: 'export KUBECONFIG=$HOME/.kube/config'
    create: true
  loop: "{{ users_k8s }}"

# 6) Bash aliases: deploy and ensure sourced in .bashrc
- name: Deploy bash aliases file
  ansible.builtin.copy:
    src: "bash_aliases"
    dest: "/home/{{ item.name }}/{{ bash_aliases_file }}"
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0644'
  loop: "{{ users_k8s }}"
  when: bash_aliases_enable | default(true)

- name: Ensure .bash_aliases is sourced in .bashrc (idempotent)
  ansible.builtin.lineinfile:
    path: "/home/{{ item.name }}/{{ bashrc_file }}"
    regexp: '^\s*source\s+~/.bash_aliases'
    line: 'source ~/.bash_aliases'
    create: true
    state: present
  loop: "{{ users_k8s }}"
  when: bash_aliases_enable | default(true)

# 7) kubectl completion per user (only generates if not present)
- name: Ensure bash-completion dir exists for each user
  ansible.builtin.file:
    path: "/home/{{ item.name }}/.local/share/bash-completion/completions"
    state: directory
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0700'
  loop: "{{ users_k8s }}"
  when: kubectl_completion_enable | default(true)

- name: Generate kubectl completion file (idempotent via creates)
  ansible.builtin.shell: >
    kubectl completion bash >
    /home/{{ item.name }}/.local/share/bash-completion/completions/kubectl
  args:
    creates: "/home/{{ item.name }}/.local/share/bash-completion/completions/kubectl"
  become: true
  become_user: "{{ item.name }}"
  loop: "{{ users_k8s }}"
  when: kubectl_completion_enable | default(true)

# 8) Create ~/bin and symlink common tools for each user (optional convenience)
- name: Ensure per-user ~/bin exists
  ansible.builtin.file:
    path: "/home/{{ item.name }}/bin"
    state: directory
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0755'
  loop: "{{ users_k8s }}"

# If you keep this, it only links existing binaries (no git involved here)
- name: Stat tool binaries on remote hosts (per user/tool pair)
  ansible.builtin.stat:
    path: "{{ item.1.src }}"
  register: tools_stat
  loop: "{{ users_k8s | product(tools_symlinks | default([])) | list }}"
  loop_control:
    label: "{{ item.0.name }} <- {{ item.1.name }}"

- name: Symlink tools into per-user ~/bin (only if src exists on remote)
  ansible.builtin.file:
    src: "{{ item.item.1.src }}"
    dest: "/home/{{ item.item.0.name }}/bin/{{ item.item.1.name }}"
    state: link
    force: true
  loop: "{{ tools_stat.results | default([]) }}"
  when: item.stat.exists
  loop_control:
    label: "{{ item.item.0.name }} <- {{ item.item.1.name }}"

# 9) Git: cloner / mettre à jour les dépôts déclarés par utilisateur
- name: Installer git (si absent)
  ansible.builtin.package:
    name: git
    state: present
  become: true

# Option: durcir la vérif d'hôte (préférable si host_key_checking=True)
- name: Ajouter github.com au known_hosts de chaque user
  ansible.builtin.known_hosts:
    path: "/home/{{ item.name }}/.ssh/known_hosts"
    name: "github.com"
    key: "github.com {{ lookup('ansible.builtin.pipe', 'ssh-keyscan -t rsa,ed25519 github.com') }}"
    state: present
  loop: "{{ users_k8s }}"
  become: true
  become_user: "{{ item.name }}"
  when: (git_known_hosts_enable | default(true))

# Option: durcir la vérif d'hôte (préférable si host_key_checking=True)
- name: Ajouter github.com au known_hosts de chaque user
  ansible.builtin.known_hosts:
    path: "/home/{{ item.name }}/.ssh/known_hosts"
    name: "github.com"
    key: "github.com {{ lookup('ansible.builtin.pipe', 'ssh-keyscan -t rsa,ed25519 github.com') }}"
    state: present
  loop: "{{ users_k8s }}"
  become: true
  become_user: "{{ item.name }}"
  when: (git_known_hosts_enable | default(true))

# --- Preflight : vérifier que le fichier Vault du rôle existe ---
- name: "[preflight] Verify vaulted key exists in role files"
  ansible.builtin.stat:
    path: "{{ role_path }}/files/id_deploy_nudger"
  delegate_to: localhost
  run_once: true
  become: false
  register: vaulted_key_stat

- name: "[preflight] Fail early if vaulted key missing"
  ansible.builtin.fail:
    msg: "roles/users-config/files/id_deploy_nudger introuvable ou mal placé."
  when: not vaulted_key_stat.stat.exists
  delegate_to: localhost
  run_once: true
  become: false

# --- Déployer la clé privée depuis le fichier Vault du rôle ---
- name: Install per-user deploy key for GitHub (from vaulted file)
  ansible.builtin.copy:
    src: "id_deploy_nudger"                 # vient de roles/users-config/files/
    dest: "/home/{{ item.name }}/.ssh/id_deploy_nudger"
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0600'
    decrypt: yes
  loop: "{{ users_k8s }}"
  become: true
  # no_log: true   # remet-le après debug
  when: item.git_repos is defined and item.git_repos | length > 0
# Déployer la clé privée depuis le fichier vaulté du rôle
- name: Install per-user deploy key for GitHub (from vaulted file)
  ansible.builtin.copy:
    src: "id_deploy_nudger"            # pris depuis roles/users-config/files/
    dest: "/home/{{ item.name }}/.ssh/id_deploy_nudger"
    owner: "{{ item.name }}"
    group: "{{ item.name }}"
    mode: '0600'
    decrypt: yes                       # déchiffre le fichier Vault
  loop: "{{ users_k8s }}"
  become: true
  no_log: true
  when: item.git_repos is defined and item.git_repos | length > 0

# Créer les répertoires cible des dépôts
- name: Créer le répertoire destination pour chaque dépôt
  ansible.builtin.file:
    path: "{{ item.1.dest }}"
    state: directory
    owner: "{{ item.0.name }}"
    group: "{{ item.0.name }}"
    mode: "0755"
  loop: "{{ users_k8s | subelements('git_repos', skip_missing=True) }}"
  loop_control:
    label: "{{ item.0.name }} -> {{ item.1.dest }}"
  become: true

# Clone/update via clé dédiée (plus d'agent)
- name: Cloner / mettre à jour les dépôts via SSH (clé dédiée)
  ansible.builtin.git:
    repo: "{{ item.1.repo }}"
    dest: "{{ item.1.dest }}"
    version: "{{ item.1.version | default('main') }}"
    update: true
    force: false
    depth: "{{ 1 if (item.1.shallow | default(true)) else omit }}"
    recursive: "{{ item.1.submodules | default(true) }}"
    track_submodules: "{{ item.1.submodules | default(true) }}"
    key_file: "/home/{{ item.0.name }}/.ssh/id_deploy_nudger"
    accept_newhostkey: true
  loop: "{{ users_k8s | subelements('git_repos', skip_missing=True) }}"
  loop_control:
    label: "{{ item.0.name }} <- {{ item.1.repo }}"
  become: true
  become_user: "{{ item.0.name }}"
  when:
    - item.1.repo is defined
    - item.1.dest is defined

