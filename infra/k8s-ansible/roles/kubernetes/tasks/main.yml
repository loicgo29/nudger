---
- name: Check active swap
  ansible.builtin.command: swapon --noheadings --show=NAME
  register: _swapon
  changed_when: false
  failed_when: false
  tags: [swap]

- name: Disable swap at runtime if any is active
  ansible.builtin.command: swapoff -a
  when: _swapon.stdout | trim | length > 0
  changed_when: true
  tags: [swap]

- name: Comment swap entries in /etc/fstab (keep a backup)
  ansible.builtin.replace:
    path: /etc/fstab
    regexp: '^\s*([^#].*\s+swap\s+.*)$'
    replace: '# \1'
    backup: true
  when: disable_swap_comment_fstab | bool
  tags: [swap, fstab]

- name: Create systemd unit to ensure swap is off at boot
  ansible.builtin.copy:
    dest: "/etc/systemd/system/{{ disable_swap_unit_name }}"
    mode: "0644"
    content: |
      [Unit]
      Description=Disable swap at boot (required by Kubernetes)
      Before=kubelet.service
      DefaultDependencies=no
      After=local-fs.target

      [Service]
      Type=oneshot
      ExecStart=/sbin/swapoff -a
      RemainAfterExit=yes

      [Install]
      WantedBy=multi-user.target
  when: disable_swap_create_systemd_unit | bool
  notify: Reload systemd
  tags: [swap, systemd]

- name: Enable + start disable-swap service
  ansible.builtin.systemd:
    name: "{{ disable_swap_unit_name }}"
    enabled: true
    state: started
  when: disable_swap_create_systemd_unit | bool
  tags: [swap, systemd]

- name: Set vm.swappiness sysctl
  ansible.posix.sysctl:
    name: vm.swappiness
    value: "{{ disable_swap_sysctl_value }}"
    state: present
    sysctl_set: true
    reload: true
  when: disable_swap_set_sysctl | bool
  tags: [swap, sysctl]

- name: Show final swap status (for logs)
  ansible.builtin.command: swapon --show
  register: _swap_status
  changed_when: false
  failed_when: false
  tags: [swap]

- name: Debug final swap status
  ansible.builtin.debug:
    msg: >-
      Swap actif ? {{ (_swap_status.stdout | trim) != '' }}
  tags: [swap]

# ----------------------------
# Kubernetes APT repo + packages
# ----------------------------

# Best practice: avoid include_vars with relative paths; keep role-scoped defaults
# that can be overridden via group_vars/host_vars or -e on CLI.

- name: Ensure apt keyrings directory exists
  ansible.builtin.file:
    path: /etc/apt/keyrings
    state: directory
    mode: '0755'
  become: true
  tags: ['k8s', 'repo']

# Download upstream ASCII armored Release key.
- name: Download Kubernetes Release key (ASCII)
  ansible.builtin.get_url:
    url: "{{ kubernetes_gpg_key_url }}"
    dest: /tmp/kubernetes-release.asc
    mode: '0644'
  become: true
  tags: ['k8s', 'repo']

# Convert to a binary keyring that apt can use.
# Idempotence: guarded by creates= on the destination keyring file.
- name: Convert Release key to binary keyring
  ansible.builtin.command: >
    gpg --dearmor -o {{ kubernetes_keyring_path }} /tmp/kubernetes-release.asc
  args:
    creates: "{{ kubernetes_keyring_path }}"
  become: true
  tags: ['k8s', 'repo']

- name: Remove temporary ASCII key
  ansible.builtin.file:
    path: /tmp/kubernetes-release.asc
    state: absent
  become: true
  tags: ['k8s', 'repo']

# Clean up legacy list if it exists (older guides used kubernetes.list).
- name: Remove legacy kubernetes.list if present
  ansible.builtin.file:
    path: /etc/apt/sources.list.d/kubernetes.list
    state: absent
  become: true
  tags: ['k8s', 'repo']
# tasks/main.yml (du rôle kubernetes) — avant apt_repository:
- name: Remove legacy Kubernetes apt sources (old prod-cdn/isv format)
  ansible.builtin.shell: |
    set -euo pipefail
    for f in /etc/apt/sources.list.d/*.list /etc/apt/sources.list.d/*.sources; do
      [ -f "$f" ] || continue
      if grep -Eiq '(prod-cdn\.packages\.k8s\.io|isv:/kubernetes:/core:/stable)' "$f"; then
        rm -f "$f"
      fi
    done
  args:
    executable: /bin/bash
  register: _legacy_k8s_sources
  changed_when: _legacy_k8s_sources.rc == 0


# Add the per-minor pkgs.k8s.io repository with our keyring.
- name: Add Kubernetes APT repository (pkgs.k8s.io)
  ansible.builtin.apt_repository:
    repo: "{{ kubernetes_repo }}"
    filename: kubernetes
    state: present
    update_cache: true
  become: true
  tags: ['k8s', 'repo']

# Keep “common” apt prerequisites near where they are used for clarity.
- name: Install common APT dependencies
  ansible.builtin.apt:
    name: "{{ common_apt_dependencies }}"
    state: present
    update_cache: true
  become: true
  tags: ['k8s', 'packages']

# Install kubelet/kubeadm/kubectl from the pinned minor repo.
- name: Install Kubernetes packages
  ansible.builtin.apt:
    name: "{{ kubernetes_packages }}"
    state: present
    update_cache: true
  become: true
  notify: Restart kubelet
  tags: ['k8s', 'packages']

# Holding versions is important: kubeadm/kubelet/kubectl must match.
# This avoids inadvertent upgrades when the repo moves forward.
- name: Hold Kubernetes packages at installed version
  ansible.builtin.dpkg_selections:
    name: "{{ item }}"
    selection: hold
  loop: "{{ kubernetes_packages }}"
  become: true
  tags: ['k8s', 'packages']

# Ensure kubelet is enabled/running (kubeadm will further configure it later).
- name: Ensure kubelet service is enabled and running
  ansible.builtin.service:
    name: kubelet
    state: started
    enabled: true
  become: true
  tags: ['k8s', 'service']
